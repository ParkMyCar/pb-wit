/// Types related to target resolution.
interface types {
    /// An individual build target.
    record target {
        /// Name of the build target.
        name: string,
        /// Location of this target (e.g. build file).
        location: string,
        /// Attributes/configuration of this target.
        attributes: list<tuple<string, attribute>>,
    }

    variant attribute {
        /// Boolean value - `true` or `false`.
        boolean(bool),
        /// Text value - Raw value _not_ another target.
        text(string),
        /// List of Text.
        text-list(list<string>),
        /// Target in the current workspace.
        target(string),
        /// List of Targets
        target-list(list<string>),
    }

    /// Returned from the execution of a `rule`.
    /// 
    /// The goal of a provider is to communicate information between two rules. For example, if the
    /// Rust library 'foo' depends on the C library 'bar', then the rule to build 'bar' will return
    /// a set of `provider`s that inform the Rust rule for building 'foo' how to link 'bar'.
    record provider {
        name: string,
        values: provider-dict,
    }

    /// Dictionary of values from a `provider`.
    /// 
    /// Note: If `WIT` supported recursive types then this would instead be a `variant` structured
    /// like so:
    /// ```
    /// variant provider-value {
    ///   /// Text value.
    ///   text(string),
    ///   /// Nested value with a specific name.
    ///   nested(tuple<string, provider-value>),
    /// }
    /// ```
    resource provider-dict {
        /// Return a reference to the value corresponding to the provided key.
        get: func(key: string) -> provider-value;
    }

    variant provider-value {
        /// Text value - Raw value _not_ another target.
        text(string),
        /// File generated by a rule.
        file(string),
        /// Nested value.
        nested(provider-dict),
    }

    /// An asynchronous iterator of bytes.
    resource bytes-stream {
        /// Poll the stream, returning bytes if they are available or None if
        /// the stream has ended.
        poll-next: func(waker: waker) -> bytes-poll;
    }

    /// Polling status states for a `bytes-stream`.
    variant bytes-poll {
        pending,
        ready(option<list<u8>>),
    }

    /// Asynchronously sink bytes into some resource.
    resource bytes-sink {
        /// Start sending bytes into this sink.
        /// 
        /// As the name suggests, a call to this function only starts the
        /// process of sinking bytes. Each call of this function must by
        /// followed by a call to `poll_flush` to ensure the provided bytes are
        /// flushed to the underlying resource..
        start-send: func(bytes: list<u8>);

        /// Flush any staged bytes to the underlying resource.
        poll-flush: func(waker: waker) -> flush-poll;
    }

    /// Polling status states for a flushing a `bytes-sink`.
    variant flush-poll {
        pending,
        ready,
    }

    /// A `waker` is a handle for notifying some executing runtime that the current task is ready to
    /// be run.
    resource waker {
        wake: func();
        clone: func() -> waker;
    }
}
