/// Types related to target resolution.
interface types {
    /// An individual build target.
    record target {
        /// Name of the build target.
        name: string,
        /// Location of this target (e.g. build file).
        location: string,
        /// Attributes/configuration of this target.
        attributes: list<tuple<string, attribute>>,
    }

    variant attribute {
        /// Boolean value - `true` or `false`.
        boolean(bool),
        /// Text value - Raw value _not_ another target.
        text(string),
        /// List of Text.
        text-list(list<string>),
        /// Target in the current workspace.
        target(string),
        /// List of Targets
        target-list(list<string>),
    }

    /// Returned from the execution of a `rule`.
    /// 
    /// The goal of a provider is to communicate information between two rules. For example, if the
    /// Rust library 'foo' depends on the C library 'bar', then the rule to build 'bar' will return
    /// a set of `provider`s that inform the Rust rule for building 'foo' how to link 'bar'.
    record provider {
        name: string,
        values: provider-dict,
    }

    /// Dictionary of values from a `provider`.
    /// 
    /// Note: If `WIT` supported recursive types then this would instead be a `variant` structured
    /// like so:
    /// ```
    /// variant provider-value {
    ///   /// Text value.
    ///   text(string),
    ///   /// Nested value with a specific name.
    ///   nested(tuple<string, provider-value>),
    /// }
    /// ```
    resource provider-dict {
        /// Return a reference to the value corresponding to the provided key.
        get: func(key: string) -> provider-value;
    }

    variant provider-value {
        /// Text value - Raw value _not_ another target.
        text(string),
        /// File generated by a rule.
        file(string),
        /// Nested value.
        nested(borrow<provider-dict>),
    }

    /// A `waker` is a handle for notifying some executing runtime that the current task is ready to
    /// be run.
    resource waker {
        wake: func();
    }
}
